#Использовать decorator

Перем РазобранноеВыражение;

Перем мВыражение;
Перем мИнтерфейс;

Перем СодержитВозвратЗначения;
Перем ЭтоЛямбдаВыражение;

Функция Интерфейс(Интерфейс) Экспорт

	ЭтоФункция = Интерфейс.ПолучитьКартуИнтерфейса()[0].ЭтоФункция;

	Если ЭтоФункция Тогда
		
		Если СтрЧислоСтрок(РазобранноеВыражение.Тело) > 1
			И СодержитВозвратЗначения.НайтиСовпадения(РазобранноеВыражение.Тело).Количество() = 0 Тогда

			ВызватьИсключение Новый ИнформацияОбОшибке(
				"Лямбда выражение должно возвращать значения",
				мВыражение
			);

		КонецЕсли;

		Если СтрЧислоСтрок(РазобранноеВыражение.Тело) = 1 
			И СтрНайти(РазобранноеВыражение.Тело, "Возврат") = 0 Тогда

			РазобранноеВыражение.Тело = "Возврат " + РазобранноеВыражение.Тело; 

		КонецЕсли;

	ИначеЕсли СодержитВозвратЗначения.НайтиСовпадения(РазобранноеВыражение.Тело).Количество() <> 0 Тогда

		ВызватьИсключение Новый ИнформацияОбОшибке(
			"Лямбда выражение не должно возвращать значение",
			мВыражение
		);


	КонецЕсли;

	мИнтерфейс = Интерфейс;

	Возврат ЭтотОбъект;

КонецФункции

Функция ВДействие() Экспорт
	
	Объект = ВОбъект();

	Возврат Новый Действие(
		Объект,
		мИнтерфейс.ПолучитьКартуИнтерфейса()[0].Имя
	);

КонецФункции

Функция ВОбъект() Экспорт
	
	Если Не ЗначениеЗаполнено(мИнтерфейс) Тогда
		ОпределитьИнтерфейс();
	КонецЕсли;

	МетодИнтерфейса = мИнтерфейс.ПолучитьКартуИнтерфейса()[0];

	Метод = Новый Метод(МетодИнтерфейса.Имя)
		.Публичный()
		.ТелоМетода(РазобранноеВыражение.Тело);

	Для каждого ИмяПараметра Из РазобранноеВыражение.Параметры Цикл
		Метод.Параметр(Новый ПараметрМетода(ИмяПараметра));
	КонецЦикла;

	Построитель = Новый ПостроительДекоратора();

	ТекстОбъекта = Построитель
		.Метод(Метод)
		.ТекстСценария();

	Если Не МетодИнтерфейса.ЭтоФункция Тогда

		ТекстОбъекта = СтрЗаменить(ТекстОбъекта, "Функция", "Процедура");
		ТекстОбъекта = СтрЗаменить(ТекстОбъекта, "КонецФункции", "КонецПроцедуры");

	КонецЕсли;

	Объект = Построитель.Построить(ТекстОбъекта);

	Рефлектор = Новый РефлекторОбъекта(Объект);

	Рефлектор.РеализуетИнтерфейс(мИнтерфейс, Истина);

	Возврат Объект;

КонецФункции

Процедура РазобратьВыражение(Выражение)
	
	Если Не ЭтоЛямбдаВыражение.Совпадает(Выражение) Тогда
		ВызватьИсключение Новый ИнформацияОбОшибке("Переданное выражение не является лямбда выражением", Выражение);
	КонецЕсли;

	Совпадения = ЭтоЛямбдаВыражение.НайтиСовпадения(Выражение);
	
	РазобранноеВыражение.Параметры = СтрРазделить(
		Совпадения[0].Группы[1].Значение,
		","
	);

	РазобранноеВыражение.Тело = Совпадения[0].Группы[2].Значение;

КонецПроцедуры

Процедура ОпределитьИнтерфейс()
	
	ЭтоФункция           = СодержитВозвратЗначения.НайтиСовпадения(РазобранноеВыражение.Тело).Количество() <> 0;
	КоличествоПараметров = РазобранноеВыражение.Параметры.Количество();

	Если ЭтоФункция Тогда

		Если КоличествоПараметров = 1 Тогда
			мИнтерфейс = ФункциональныеИнтерфейсы.УниФункция();
		ИначеЕсли КоличествоПараметров = 2 Тогда
			мИнтерфейс = ФункциональныеИнтерфейсы.БиФункция();
		ИначеЕсли КоличествоПараметров = 3 Тогда
			мИнтерфейс = ФункциональныеИнтерфейсы.ТерФункция();
		КонецЕсли;

	Иначе

		Если КоличествоПараметров = 1 Тогда
			мИнтерфейс = ФункциональныеИнтерфейсы.УниПроцедура();
		ИначеЕсли КоличествоПараметров = 2 Тогда
			мИнтерфейс = ФункциональныеИнтерфейсы.БиПроцедура();
		ИначеЕсли КоличествоПараметров = 3 Тогда
			мИнтерфейс = ФункциональныеИнтерфейсы.ТерПроцедура();
		КонецЕсли;

	КонецЕсли;

	Если Не ЗначениеЗаполнено(мИнтерфейс) Тогда

		Параметры = Новый Структура(
			"Выражение, ЭтоФУнкция, КоличествоПараметров",
			мВыражение,
			ЭтоФункция,
			КоличествоПараметров
		);

		ВызватьИсключение Новый ИнформацияОбОшибке(
			"Невозможно определить функциональный интерфейс для лямбда выражения",
			Параметры
		);

	КонецЕсли;

КонецПроцедуры

Процедура ПриСозданииОбъекта(Выражение)

	РазобратьВыражение(Выражение);

	мВыражение = Выражение;

КонецПроцедуры

РазобранноеВыражение = Новый Структура(
	"Параметры, Тело"
);

СодержитВозвратЗначения = Новый РегулярноеВыражение("[^\S]+Возврат\s+[^;\s]+\s*;?");
ЭтоЛямбдаВыражение = Новый РегулярноеВыражение("\(\s*(.+)\s*\)\s*->\s*\{?([^\}]+)\}?");
